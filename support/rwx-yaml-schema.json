{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://rwx.com/docs/rwx-ci-yaml-v1.json",
  "title": "RWX YAML Configuration Schema",
  "description": "JSON Schema for RWX CI/CD YAML configuration files. RWX is a distributed build system and CI/CD platform that orchestrates task execution across containerized environments with sophisticated caching, artifact management, and agent-based distributed execution.",
  "type": "object",
  "properties": {
    "tasks": {
      "type": "array",
      "minItems": 1,
      "description": "An array of task definitions that form the core execution units of your workflow. Each task represents a discrete unit of work that executes in an isolated containerized environment. Tasks can execute shell commands, call reusable packages, or embed other run definitions. Tasks support sophisticated dependency management through 'use' (inherits outputs and filesystem) and 'after' (ordering only), enabling complex workflows with parallel execution, content-based caching, and flexible artifact management.",
      "items": {
        "oneOf": [
          { "$ref": "#/$defs/CommandTask" },
          { "$ref": "#/$defs/PackageTask" },
          { "$ref": "#/$defs/EmbeddedRunTask" }
        ]
      }
    },
    "on": {
      "$ref": "#/$defs/Triggers",
      "description": "Trigger configuration that defines when and how this run should execute. Mint supports five trigger types: GitHub events (push, pull_request), GitLab events (push, tag-push, merge-request), scheduled cron jobs, manual CLI execution, and API dispatch triggers. Each trigger provides rich event context accessible via template expressions (e.g., ${{ event.git.branch }}, ${{ event.github.push.head_commit.message }}). Triggers can specify conditions (if), initialization parameters (init), target tasks (target), and custom run titles (title). Event data flows into tasks through initialization parameters, enabling dynamic workflow behavior based on trigger context."
    },
    "concurrency-pools": {
      "type": "array",
      "description": "Configuration for concurrency pools that limit the number of concurrent runs executing based on pool identifiers. Pools are global to your organization (not repository-scoped) and help manage resource contention. When capacity is exceeded, you can configure whether additional runs should queue, cancel waiting runs, or cancel currently running runs. Commonly used for managing deployments, feature branch workflows, and shared resource access. Best practice is to include repository name in pool ID to avoid conflicts (e.g., 'my-org/my-repo:deployment').",
      "items": { "$ref": "#/$defs/ConcurrencyPool" }
    },
    "tool-cache": {
      "$ref": "#/$defs/ToolCache",
      "description": "Global tool cache configuration that enables incremental caching for tasks across runs. Tool caches preserve filesystem contents from previous task executions, allowing tasks like dependency installations to perform incremental updates instead of starting from scratch. When a task has a cache miss, the tool cache provides the filesystem state from the most recent execution. Tool caches are evicted after 48 hours and must be configured with a vault for security. Ideal for package managers (npm, yarn, bundle), Docker builds, and other tasks that benefit from incremental updates."
    },
    "base": {
      "$ref": "#/$defs/BaseLayer",
      "description": "Base container layer configuration that defines the operating system, version, and Mint configuration tag for task execution. All tasks inherit from this base layer unless they specify their own base configuration. Currently supports Ubuntu 22.04 (tag 1.0 with Docker 26.0.1) and Ubuntu 24.04 (tag 1.1 with Docker 28.0.4). The base layer determines available system packages, pre-installed Docker version, and tool cache compatibility. Different embedded runs can specify different base layers than their parent run."
    }
  },
  "required": ["tasks"],
  "unevaluatedProperties": false,

  "$defs": {
    "PrimitiveValue": {
      "oneOf": [
        { "type": "string" },
        { "type": "number" },
        { "type": "boolean" }
      ],
      "description": "A primitive value that can be a string, number, or boolean. All values are cast to strings by the RWX system."
    },
    "CommandTask": {
      "type": "object",
      "description": "A task that executes shell commands in a containerized environment. Command tasks are the most common task type and can run any shell command, script, or executable. They support sophisticated features like parallel execution, background processes, artifact outputs, and environment variable management.",
      "properties": {
        "key": {
          "type": "string",
          "pattern": "^[a-zA-Z0-9_][a-zA-Z0-9_\\-\\.]*$",
          "description": "A unique identifier for the task used for dependencies, artifact references, and display purposes. Must start with a letter, number, or underscore, followed by any combination of letters, numbers, underscores, hyphens, or dots. Keys serve as display names in the UI and logs and must be unique within the run definition. Common patterns include kebab-case (build-frontend), underscore_case (set_env_one), and descriptive names (deploy-production)."
        },
        "run": {
          "oneOf": [
            { "type": "string" },
            { "type": "array", "items": { "type": "string" } }
          ],
          "description": "The shell command(s) to execute in the task container. Can be a single command string, a multi-line string using YAML's pipe (|) operator, or an array of command strings executed sequentially. Commands run in a bash shell with full access to environment variables, pipes, and redirects. Supports template expressions like ${{ init.parameter }} for dynamic command generation. Multi-line strings preserve formatting and are ideal for complex scripts."
        },
        "use": {
          "$ref": "#/$defs/Dependencies",
          "description": "Specifies task dependencies that must complete successfully before this task runs. Dependencies provide both execution ordering and inheritance of file system contents and environment variables. Files from dependency tasks are merged into this task's workspace in the order specified. If multiple dependencies produce the same file, the last dependency in the list takes precedence. Environment variables exported by dependencies (via $MINT_ENV) are automatically available in this task."
        },
        "after": {
          "$ref": "#/$defs/After",
          "description": "Specifies execution ordering constraints without data inheritance. Tasks listed in 'after' must complete (successfully or not) before this task starts, but unlike 'use', no files or environment variables are inherited. Supports expressions for conditional execution based on task status (e.g., ${{ task.failed }}). Common for cleanup workflows, deployment pipelines with side effects, and build optimization scenarios."
        },
        "if": {
          "type": "string",
          "description": "A boolean expression that determines whether the task executes. If false, the task is skipped along with any dependent tasks. Supports template expressions with boolean operators (&&, ||), comparison operators (==, !=), regex matching (=~, !~), and utility functions (starts-with, contains, etc.). Best practice is to use init parameters for conditions to enable CLI testing with --init flags."
        },
        "agent": {
          "$ref": "#/$defs/AgentSpecification",
          "description": "Specifies compute resource requirements for the task execution agent. Default allocation is 2 CPUs, 8GB memory, and 50GB disk. Can specify memory (with units like 'gb'), CPU count, disk space (in 50GB increments), and special features like static IPs or tmpfs. Choose agent specifications based on task requirements - use larger agents for compilation or data processing, smaller agents for simple operations. Different tasks can use different agent specifications for cost optimization."
        },
        "docker": {
          "oneOf": [
            { "type": "boolean" },
            { "type": "string", "enum": ["preserve-data"] },
            { "type": "string" }
          ],
          "description": "Docker daemon configuration for container operations within the task. Options: 'true' (basic Docker with cleanup), 'preserve-data' (Docker with persistence for images, volumes, build cache), or 'false' (disabled). The preserve-data option is essential for pre-pulling and caching large container images, sharing Docker volumes between dependent tasks, enabling incremental Docker builds with build cache, and setting up persistent database containers for testing."
        },
        "parallel": {
          "$ref": "#/$defs/ParallelConfiguration",
          "description": "Parallelism configuration for generating multiple task instances with different parameters. Types: 'total' (numeric value creating indexed parallel tasks), 'matrix' (all combinations of specified variable arrays), 'values' (explicit array of parameter objects). Generated tasks receive context variables like parallel.index, parallel.total, and parallel.<variable-name>. Limits: 1-256 tasks (default 16, configurable with tasks-limit)."
        },
        "env": {
          "$ref": "#/$defs/EnvironmentVariables",
          "description": "Environment variable configuration for task execution context. Formats: simple key-value pairs or advanced objects with 'value' and 'cache-key' properties. Cache behavior: 'included' (default, variable value affects cache key), 'excluded' (variable ignored for caching, enabling cache hits with ephemeral values like credentials). Tasks can export variables to $MINT_ENV/ for use in dependent tasks. Variables from 'use' dependencies are automatically inherited."
        },
        "env-config": {
          "$ref": "#/$defs/EnvironmentConfiguration",
          "description": "Configuration for how environment variables from dependency tasks are merged. Default behavior: later tasks in 'use' array overwrite earlier values. Special case: PATH is automatically joined with ':' separator. Merge configuration: 'strategy: join' concatenates values with specified separator. Primarily used for PATH-like variables that need combining rather than replacement."
        },
        "cache": {
          "$ref": "#/$defs/CacheConfiguration",
          "description": "Configure content-based caching behavior for the task. Mint automatically caches tasks based on their inputs, but you can control caching with boolean values or TTL (time-to-live) settings. When disabled, tasks will always execute. TTL formats: '1 min/minute', '1 hr/hour', '1 day' for automatic cache expiration. When configured with a TTL, caches will automatically expire after the specified duration."
        },
        "tool-cache": {
          "type": "string",
          "description": "Reference to a named tool cache for incremental caching. The tool cache preserves the filesystem contents from previous executions of this task, enabling incremental updates when the task has a cache miss. Particularly effective for dependency installation tasks like npm install, bundle install, or yarn install. Tool cache names should be unique within the vault and descriptive of their purpose. The global tool-cache vault configuration must be set for task-level tool caches to function."
        },
        "filter": {
          "oneOf": [
            { "type": "string" },
            { "type": "array", "items": { "type": "string" } },
            { "$ref": "#/$defs/InputFilesystemFilter" }
          ],
          "description": "Specify which files from the workspace should be present for the task execution. Filters use glob patterns and improve cache hit rates by ensuring tasks only depend on relevant files. Only affects the workspace directory (/var/mint-workspace), not system files. Supports patterns: '*' (match within segment), '**' (match across segments), '{}' (comma-delimited options), '!' (negate/exclude)."
        },
        "background-processes": {
          "type": "array",
          "description": "Define background services that run alongside the main task command. Supports ready checks to ensure services are available before the main command executes, and dependency sequencing between background processes. Processes start in parallel unless 'after' is specified. Default ready-check timeout: 60 seconds. Use service-specific tools for ready checks when possible.",
          "items": { "$ref": "#/$defs/BackgroundProcess" }
        },
        "outputs": {
          "$ref": "#/$defs/OutputConfiguration",
          "description": "Configure different types of task outputs including file artifacts, test result parsing, output values for other tasks, and problem detection from logs or files. Artifacts are preserved as downloadable files, test results integrate with UI display, output values enable task communication via $MINT_VALUES directory, and problems support built-in matchers (eslint, rubocop, etc.) or custom formats."
        },
        "timeout": {
          "type": "string",
          "minimum": 1,
          "description": "Maximum execution time for the task (default: 10 minutes), with a unit like 'm' or 'h' on the end (e.g. `timeout: 30m`). If the task runs longer than this timeout, it will be terminated with a SIGKILL signal (or SIGTERM if terminate-grace-period-seconds is set). The timeout applies to the entire task execution, including any background processes and their ready checks. Helps prevent runaway tasks from consuming resources indefinitely."
        },
        "timeout-minutes": {
          "type": "integer",
          "minimum": 1,
          "description": "Maximum execution time for the task in minutes (default: 10 minutes). If the task runs longer than this timeout, it will be terminated with a SIGKILL signal (or SIGTERM if terminate-grace-period-seconds is set). The timeout applies to the entire task execution, including any background processes and their ready checks. Helps prevent runaway tasks from consuming resources indefinitely."
        },
        "terminate-grace-period-seconds": {
          "type": "integer",
          "minimum": 0,
          "description": "Grace period in seconds to allow for clean shutdown when the task is terminated due to timeout or cancellation (default: 0 for immediate SIGKILL). During this period, the task process receives a SIGTERM signal and can perform cleanup operations (releasing locks, closing connections, saving state) before being forcefully terminated with SIGKILL. Essential for tasks that manage external resources like Terraform locks."
        },
        "retry": {
          "$ref": "#/$defs/RetryConfiguration",
          "description": "Retry configuration that specifies how many times to retry the task if it fails and what action to take on retry. Retries help handle transient failures like network issues, resource contention, or flaky tests. Each retry attempt gets a fresh execution environment. Advanced retry actions can be configured to customize retry behavior, set debug flags, or provide retry-specific data via $MINT_RETRY_ACTIONS directory."
        }
      },
      "required": ["key", "run"],
      "unevaluatedProperties": false
    },

    "PackageTask": {
      "type": "object",
      "description": "A task that calls a reusable package. Package tasks allow you to invoke pre-built, versioned components that encapsulate common functionality. Packages provide reusable workflow building blocks with defined parameter schemas, similar to GitHub Actions but optimized for Mint's execution model.",
      "properties": {
        "key": {
          "type": "string",
          "pattern": "^[a-zA-Z0-9_][a-zA-Z0-9_\\-\\.]*$",
          "description": "An identifier for the task. Keys are used for referencing the task within other tasks through dependencies and artifact references. They also serve as the display name of the task within the UI and logs. Must be unique within the run definition."
        },
        "call": {
          "oneOf": [
            {
              "type": "string",
              "pattern": "^[a-z0-9-]+/[a-z0-9-]+\\s+[0-9]+\\.[0-9]+\\.[0-9]+$"
            },
            { "type": "string", "pattern": "^[a-f0-9]{64}$" }
          ],
          "description": "The package identifier specifying which package to call. Use name/version format (e.g., 'namespace/package-name 1.2.0') for semantic versioning or SHA-256 digest for exact version pinning. Packages must be published and available in your organization's package registry. Version format follows semantic versioning (major.minor.patch)."
        },
        "with": {
          "type": "object",
          "additionalProperties": { "$ref": "#/$defs/PrimitiveValue" },
          "description": "Parameters to pass to the package. Each package defines its own parameter schema that specifies required and optional parameters with their types and defaults. Parameters can use template expressions to pass dynamic values like outputs from other tasks, initialization parameters, or event context. All values are converted to strings by the system."
        },
        "use": { "$ref": "#/$defs/Dependencies" },
        "after": { "$ref": "#/$defs/After" },
        "if": {
          "type": "string",
          "description": "An expression that determines whether the task should execute. If the expression evaluates to 'false', the task will be skipped."
        },
        "env": { "$ref": "#/$defs/EnvironmentVariables" },
        "env-config": { "$ref": "#/$defs/EnvironmentConfiguration" },
        "cache": { "$ref": "#/$defs/CacheConfiguration" },
        "parallel": { "$ref": "#/$defs/ParallelConfiguration" },
        "filter": {
          "oneOf": [{ "$ref": "#/$defs/FilterSet" }, { "type": "string" }],
          "description": "Input filtering for package tasks specifying which workspace files should be available to the package. Uses glob patterns to include or exclude files from the package execution environment. Package tasks only support workspace filtering (not system file filtering) and cannot filter artifacts from other tasks. Helps optimize performance and cache behavior."
        }
      },
      "required": ["key", "call"],
      "unevaluatedProperties": false
    },

    "EmbeddedRunTask": {
      "type": "object",
      "description": "A task that executes another run definition as a sub-run. Embedded run tasks allow you to compose complex workflows by including other run definitions from the same repository or external sources. This enables modularity and reuse of common workflow patterns like CI pipelines, deployment processes, or test suites. Different embedded runs can specify different base layers than their parent run.",
      "properties": {
        "key": {
          "type": "string",
          "pattern": "^[a-zA-Z0-9_][a-zA-Z0-9_\\-\\.]*$",
          "description": "An identifier for the task. Keys are used for referencing the task within other tasks through dependencies and artifact references. They also serve as the display name of the task within the UI and logs. Must be unique within the run definition."
        },
        "call": {
          "type": "string",
          "not": {
            "oneOf": [
              {
                "pattern": "^[a-z0-9-]+/[a-z0-9-]+\\s+[0-9]+\\.[0-9]+\\.[0-9]+$"
              },
              {
                "pattern": "^[a-f0-9]{64}$"
              }
            ]
          },
          "description": "The source of the embedded run definition. Can be a file path relative to the current run definition, an absolute path, or a template expression that resolves to a run definition location. The referenced file must be a valid Mint YAML run definition. Must not match the package name/version format used by package tasks. Common patterns use ${{ run.mint-dir }} for consistent path resolution."
        },
        "init": {
          "type": "object",
          "additionalProperties": { "$ref": "#/$defs/PrimitiveValue" },
          "description": "Initialization parameters to pass to the embedded run definition. These parameters are available as template variables in the embedded run using the 'init' namespace (e.g., ${{ init.environment }}). Allows customizing the behavior of reusable run definitions based on the calling context, enabling parameterized workflows that can adapt to different environments, configurations, or input data."
        },
        "target": {
          "oneOf": [
            { "type": "string" },
            { "type": "array", "items": { "type": "string" } }
          ],
          "description": "Specific tasks within the embedded run to execute. If not specified, all tasks in the embedded run will be executed according to their dependencies. Allows selective execution of portions of larger run definitions, enabling modular workflow composition. Can be a single task key or an array of task keys. Dependencies of targeted tasks are automatically included."
        },
        "after": { "$ref": "#/$defs/After" },
        "if": {
          "type": "string",
          "description": "An expression that determines whether the task should execute. If the expression evaluates to 'false', the task will be skipped."
        },
        "cache": { "$ref": "#/$defs/CacheConfiguration" },
        "parallel": { "$ref": "#/$defs/ParallelConfiguration" }
      },
      "required": ["key", "call"],
      "unevaluatedProperties": false
    },

    "Dependencies": {
      "oneOf": [
        { "type": "string" },
        { "type": "array", "items": { "type": "string" } }
      ],
      "description": "Task keys that must complete successfully before this task can start. Can be a single task key string or an array of task keys. Dependencies ensure proper execution order and that required outputs, artifacts, or side effects are available."
    },

    "After": {
      "oneOf": [
        { "type": "string" },
        { "type": "array", "items": { "type": "string" } }
      ],
      "description": "Task keys that must complete (successfully or not) before this task starts. Unlike dependencies, 'after' constraints don't require success."
    },

    "AgentSpecification": {
      "type": "object",
      "description": "Compute resource requirements for the task execution agent. The platform will allocate or provision an agent that meets these specifications before running the task. Default allocation is 2 CPUs, 8GB memory, and 50GB disk. Supports General Purpose (2-64 CPUs, 8gb-256gb memory), Compute Optimized (2-32 CPUs, 4gb-64gb memory), and Memory Optimized (2-64 CPUs, 16gb-512gb memory) configurations.",
      "properties": {
        "memory": {
          "type": "string",
          "description": "Memory allocation for the task execution environment. Specified as a string with units like 'gb', 'mb', or 'tb'. Higher memory allocations allow for more memory-intensive tasks like large builds or data processing. Mint reserves 2GB RAM for internal use. Available: 4gb-512gb depending on configuration type."
        },
        "cpus": {
          "oneOf": [{ "type": "integer", "minimum": 1 }, { "type": "string" }],
          "description": "Number of CPU cores to allocate for the task. Can be specified as an integer or as a template expression. More CPUs enable parallel processing and faster execution for CPU-intensive tasks. Available: 2-64 CPUs depending on configuration type. Specify only CPU or memory for cost optimization - Mint selects lowest cost option."
        },
        "disk": {
          "oneOf": [
            { "type": "string" },
            {
              "type": "object",
              "properties": {
                "size": {
                  "type": "string",
                  "description": "Disk space allocation with units like 'gb' or 'tb'"
                }
              }
            }
          ],
          "description": "Disk space allocation for the task execution environment. Can be specified as a simple string or as an object with a size property. Available in 50GB increments starting from 50GB (default). Larger disk allocations support tasks that generate large artifacts or work with large datasets."
        },
        "static-ips": {
          "type": "string",
          "description": "Request for static IP addresses for the task execution environment. Useful for tasks that need to be whitelisted by external services or require consistent network identity. Requires vault configuration for static IP management. Often used with template expressions to reference vault settings."
        },
        "tmpfs": {
          "type": "boolean",
          "description": "Whether to use tmpfs (in-memory filesystem) for improved I/O performance. Useful for tasks with heavy disk I/O that can benefit from memory-backed storage, but requires sufficient memory allocation. Benefits tasks with significant filesystem I/O that fit in ~70% of available memory."
        },
        "spot": {
          "type": "boolean",
          "description": "Whether to use spot instances for task execution. When true, uses ephemeral instances that may be preempted at any time but offer cost savings. When false or omitted, uses standard on-demand instances with guaranteed availability and stable performance. Choose spot instances for fault-tolerant workloads that can handle interruptions."
        }
      },
      "unevaluatedProperties": false
    },

    "ParallelConfiguration": {
      "oneOf": [
        { "type": "integer", "minimum": 1, "maximum": 256 },
        { "type": "string" },
        {
          "type": "object",
          "properties": {
            "key": {
              "type": "string",
              "description": "Custom naming pattern for generated parallel tasks. Supports template expressions using parallel variables (e.g., 'build-${{ parallel.os }}-${{ parallel.arch }}'). If not specified, tasks are named with numeric suffixes."
            },
            "tasks-limit": {
              "type": "integer",
              "minimum": 1,
              "maximum": 256,
              "description": "Maximum number of parallel tasks to run concurrently (default: 16, max: 256). Helps control resource usage and agent allocation. Useful when matrix/values would generate more tasks than desired."
            },
            "total": {
              "$ref": "#/$defs/PrimitiveValue",
              "description": "Total number of parallel executions to create (0 to n-1). Each execution gets its own parallel.index and parallel.total variables accessible via ${{ parallel.index }} and environment variables $MINT_PARALLEL_INDEX, $MINT_PARALLEL_TOTAL."
            },
            "matrix": {
              "type": "object",
              "additionalProperties": {
                "oneOf": [
                  { "$ref": "#/$defs/PrimitiveValue" },
                  {
                    "type": "array",
                    "items": { "$ref": "#/$defs/PrimitiveValue" }
                  }
                ]
              },
              "description": "Matrix parallelism that creates all combinations of specified variable arrays. Each combination becomes a separate parallel execution with access to the matrix variables via ${{ parallel.variable-name }}. Generates the cartesian product of all specified arrays."
            },
            "values": {
              "oneOf": [
                { "type": "string" },
                {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "additionalProperties": { "$ref": "#/$defs/PrimitiveValue" }
                  }
                }
              ],
              "description": "Explicit list of parameter objects for parallel execution. Each object becomes a separate parallel execution with access to the specified variables via ${{ parallel.variable-name }}. All objects must have the same keys. Alternative to matrix when you need specific combinations rather than cartesian product."
            }
          },
          "unevaluatedProperties": false
        }
      ],
      "description": "Parallelism configuration for generating multiple task instances with different parameters. Types: 'total' (numeric value creating indexed parallel tasks 0 to n-1), 'matrix' (all combinations of specified variable arrays), 'values' (explicit array of parameter objects with same keys). Generated tasks receive context variables: parallel.index/parallel.total for numeric, parallel.<variable-name> for matrix/values. Environment variables: $MINT_PARALLEL_INDEX, $MINT_PARALLEL_TOTAL. Limits: 1-256 tasks (default 16, configurable with tasks-limit)."
    },

    "EnvironmentVariables": {
      "type": "object",
      "additionalProperties": {
        "oneOf": [
          { "type": "string" },
          { "type": "number" },
          { "type": "boolean" },
          {
            "type": "object",
            "properties": {
              "value": {
                "type": "string",
                "description": "The environment variable value. Supports template expressions for dynamic values from other tasks, initialization parameters, or event context."
              },
              "cache-key": {
                "type": "string",
                "enum": ["included", "excluded"],
                "description": "Whether this environment variable should be included in cache key generation. 'included' (default): variable value affects cache key. 'excluded': variable ignored for caching, enabling cache hits with ephemeral values like credentials."
              }
            },
            "unevaluatedProperties": false
          }
        ]
      },
      "description": "Environment variable configuration for task execution context. Formats: simple key-value pairs (VAR_NAME: value) or advanced objects with 'value' and 'cache-key' properties. Cache behavior: 'included' (default, affects cache key), 'excluded' (ignored for caching, for ephemeral credentials). Tasks can export variables to $MINT_ENV/ for use in dependent tasks. Variables from 'use' dependencies are automatically inherited. All values are converted to strings."
    },

    "EnvironmentConfiguration": {
      "type": "object",
      "description": "Configuration for how environment variables from dependency tasks are merged. Default behavior: later tasks in 'use' array overwrite earlier values. Special case: PATH is automatically joined with ':' separator. Merge configuration allows customizing this behavior for specific variables.",
      "properties": {
        "inherit": {
          "oneOf": [
            { "type": "string", "enum": ["all-used-tasks"] },
            { "type": "array", "items": { "type": "string" } }
          ],
          "description": "Inherit environment variables from dependency tasks. 'all-used-tasks' inherits from all tasks listed in 'use', or specify an array of specific task keys. Note: inheritance is automatic for 'use' dependencies; this setting provides explicit control."
        },
        "merge": {
          "type": "object",
          "additionalProperties": {
            "type": "object",
            "properties": {
              "strategy": { "type": "string", "enum": ["join", "override"] },
              "by": {
                "type": "string",
                "description": "Separator string for join strategy. Common values: ':' for PATH-like variables, ',' for comma-separated lists, ' ' for space-separated values."
              }
            }
          },
          "description": "Merge strategies for environment variables with the same name from multiple sources."
        }
      },
      "unevaluatedProperties": false
    },

    "CacheConfiguration": {
      "oneOf": [
        { "type": "boolean" },
        { "type": "string" },
        {
          "type": "object",
          "properties": {
            "enabled": {
              "oneOf": [{ "type": "boolean" }, { "type": "string" }],
              "description": "Whether caching is enabled for this task"
            },
            "ttl": {
              "type": "string",
              "description": "Time-to-live for cache entries. Supported formats: '1 min', '1 minute', '2 mins', '2 minutes', '1 hr', '1 hour', '2 hrs', '2 hours', '1 day', '2 days'. Cache entries automatically expire after the specified duration."
            }
          }
        }
      ],
      "description": "Configure content-based caching behavior for the task. Mint automatically caches tasks based on their inputs, but you can control caching with boolean values or TTL (time-to-live) settings. When disabled, tasks will always execute. TTL formats: '1 min/minute', '1 hr/hour', '1 day' for automatic cache expiration."
    },

    "BackgroundProcess": {
      "type": "object",
      "description": "A background process that runs concurrently with the main task command. Useful for services, databases, or other long-running processes that the task needs to interact with. Processes start in parallel unless 'after' is specified. Support ready checks with default 60-second timeout and graceful termination with configurable grace periods (default: 10 seconds).",
      "properties": {
        "key": {
          "type": "string",
          "pattern": "^[a-zA-Z0-9_][a-zA-Z0-9_\\-\\.]*$",
          "description": "Unique identifier for the background process within the task. Used for process ordering with 'after' dependencies and in logs/UI for identification."
        },
        "run": {
          "type": "string",
          "description": "Command to execute for the background process. Runs in the same containerized environment as the main task with access to the same filesystem and environment variables."
        },
        "ready-check": {
          "oneOf": [
            { "type": "string" },
            { "type": "array", "items": { "type": "string" } },
            {
              "type": "object",
              "properties": {
                "run": {
                  "oneOf": [
                    { "type": "string" },
                    { "type": "array", "items": { "type": "string" } }
                  ],
                  "description": "Command or commands to run to check if the background process is ready. Should be lightweight and idempotent. Use service-specific tools when possible (e.g., pg_isready for PostgreSQL, redis-cli ping for Redis)."
                },
                "timeout-seconds": {
                  "type": "integer",
                  "minimum": 1,
                  "description": "Maximum time to wait for the ready check to succeed (default: 60 seconds). Ready checks are retried until timeout is reached."
                }
              },
              "required": ["run"],
              "unevaluatedProperties": false
            }
          ],
          "description": "Configuration for checking when the background process is ready to receive requests. Can be a simple command string, array of commands, or detailed object with timeout configuration. Ready checks run repeatedly until they succeed or timeout. Use service-specific ready check commands when possible rather than generic port checks."
        },
        "after": {
          "oneOf": [
            { "type": "string" },
            { "type": "array", "items": { "type": "string" } }
          ],
          "description": "Other background processes that must be ready before starting this process. Can be a single process key or an array of process keys. Creates startup sequencing to handle service dependencies (e.g., database before web server)."
        },
        "terminate-grace-period-seconds": {
          "type": "integer",
          "minimum": 0,
          "description": "Grace period for clean shutdown when terminating the background process (default: 10 seconds). Process receives SIGTERM, then SIGKILL after grace period. Allows time for cleanup operations like flushing data or closing connections."
        }
      },
      "required": ["key", "run"],
      "unevaluatedProperties": false
    },

    "OutputConfiguration": {
      "type": "object",
      "description": "Configure different types of task outputs including file artifacts, test result parsing, output values for other tasks, and problem detection from logs or files. Artifacts are preserved as downloadable files, test results integrate with UI display, output values enable task communication via $MINT_VALUES directory, and problems support built-in matchers (eslint, rubocop, shellcheck, tsc) or custom formats.",
      "properties": {
        "execution-status": {
          "type": "object",
          "description": "Configuration for custom success/failure determination",
          "properties": {
            "success-exit-codes": {
              "type": "array",
              "items": { "type": "integer" },
              "description": "Exit codes that should be considered successful completion"
            }
          }
        },
        "test-results": {
          "type": "array",
          "description": "Test result files to process and display in the UI",
          "items": {
            "type": "object",
            "properties": {
              "path": {
                "type": "string",
                "description": "Path to test result file"
              },
              "options": {
                "type": "object",
                "properties": {
                  "framework": {
                    "type": "string",
                    "description": "Test framework name"
                  },
                  "language": {
                    "type": "string",
                    "description": "Programming language"
                  }
                },
                "required": ["framework", "language"]
              }
            },
            "required": ["path"]
          }
        },
        "values": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Names of output values that other tasks can reference"
        },
        "problems": {
          "type": "array",
          "description": "Problem detection configuration for parsing errors, warnings, and issues from task output",
          "items": {
            "type": "object",
            "oneOf": [
              {
                "properties": {
                  "matcher": {
                    "type": "string",
                    "description": "Problem matcher name or URL"
                  }
                },
                "required": ["matcher"]
              },
              {
                "properties": {
                  "path": {
                    "type": "string",
                    "description": "Path to problem file"
                  },
                  "format": {
                    "type": "string",
                    "enum": [
                      "auto",
                      "problem-json",
                      "github-annotation-json",
                      "github-annotations-action-json"
                    ],
                    "description": "Format of the problem file"
                  }
                },
                "required": ["path"]
              }
            ]
          }
        },
        "artifacts": {
          "type": "array",
          "description": "Files or directories to collect as artifacts after task completion",
          "items": {
            "type": "object",
            "properties": {
              "key": {
                "type": "string",
                "description": "Unique identifier for the artifact"
              },
              "path": {
                "type": "string",
                "description": "File or directory path to collect"
              }
            },
            "required": ["key", "path"]
          }
        },
        "filesystem": {
          "type": "object",
          "description": "Filesystem filtering for preserving files after task completion",
          "properties": {
            "filter": {
              "oneOf": [
                { "type": "array", "items": { "type": "string" } },
                {
                  "type": "object",
                  "properties": {
                    "workspace": {
                      "type": "array",
                      "items": { "type": "string" }
                    },
                    "system": { "type": "array", "items": { "type": "string" } }
                  }
                }
              ]
            }
          }
        }
      },
      "unevaluatedProperties": false
    },

    "RetryConfiguration": {
      "oneOf": [
        { "type": "string" },
        {
          "type": "object",
          "properties": {
            "count": {
              "$ref": "#/$defs/PrimitiveValue",
              "description": "Number of retry attempts"
            },
            "action": {
              "type": "string",
              "description": "Action to take on retry"
            }
          },
          "required": ["count"]
        }
      ],
      "description": "Configuration for automatic task retries on failure"
    },

    "InputFilesystemFilter": {
      "type": "object",
      "description": "Filtering configuration for input files from workspace and dependencies",
      "properties": {
        "workspace": { "type": "array", "items": { "type": "string" } },
        "system": { "type": "array", "items": { "type": "string" } }
      },
      "unevaluatedProperties": false
    },

    "FilterSet": {
      "type": "object",
      "description": "File filtering configuration",
      "properties": {
        "workspace": { "type": "array", "items": { "type": "string" } }
      },
      "unevaluatedProperties": false
    },

    "Triggers": {
      "type": "object",
      "description": "Trigger configuration defining when the run should execute",
      "properties": {
        "github": { "$ref": "#/$defs/GitHubTriggers" },
        "gitlab": { "$ref": "#/$defs/GitLabTriggers" },
        "cron": { "$ref": "#/$defs/CronTriggers" },
        "cli": { "$ref": "#/$defs/CLITrigger" },
        "dispatch": { "$ref": "#/$defs/DispatchTriggers" }
      },
      "unevaluatedProperties": false
    },

    "GitHubTriggers": {
      "type": "object",
      "description": "GitHub event triggers for automated run execution. Supports push events (on branch updates), pull_request events (on PR lifecycle), and merge_group events. Each trigger provides rich event context accessible via template expressions like ${{ event.git.branch }}, ${{ event.github.push.head_commit.message }}. Triggers can specify conditions (if), initialization parameters (init), target tasks (target), and custom run titles (title).",
      "properties": {
        "push": {
          "oneOf": [
            { "$ref": "#/$defs/GitHubPushTrigger" },
            {
              "type": "array",
              "items": { "$ref": "#/$defs/GitHubPushTrigger" }
            }
          ],
          "description": "Triggers for GitHub push events (branch updates, tag pushes). Can be a single trigger object or an array of trigger objects for different configurations. Provides event context: event.git.branch, event.git.sha, event.git.ref, event.git.tag, event.github.push.head_commit.message, event.github.push.repository.clone_url, event.github.push.sender.login."
        },
        "pull_request": {
          "oneOf": [
            { "$ref": "#/$defs/GitHubPullRequestTrigger" },
            {
              "type": "array",
              "items": { "$ref": "#/$defs/GitHubPullRequestTrigger" }
            }
          ],
          "description": "Triggers for GitHub pull request events (opened, reopened, synchronize, closed). Can be a single trigger object or an array of trigger objects. Default actions: [opened, reopened, synchronize]. Provides event context: event.git.branch, event.git.sha, event.git.ref, event.github.pull_request.number, event.github.pull_request.pull_request.title."
        },
        "merge_group": {
          "oneOf": [
            { "$ref": "#/$defs/GitHubMergeGroupTrigger" },
            {
              "type": "array",
              "items": { "$ref": "#/$defs/GitHubMergeGroupTrigger" }
            }
          ],
          "description": "Triggers for GitHub merge group events. Can be a single trigger object or an array of trigger objects."
        }
      },
      "unevaluatedProperties": false
    },

    "GitHubPushTrigger": {
      "type": "object",
      "description": "Configuration for GitHub push event triggers. Triggered on branch updates, tag pushes, and repository pushes. Supports conditional execution, initialization parameter mapping, selective task targeting, custom run titles, and GitHub status check reporting.",
      "properties": {
        "init": { "$ref": "#/$defs/InitParameters" },
        "if": {
          "type": "string",
          "description": "Condition for trigger activation"
        },
        "target": { "$ref": "#/$defs/TargetTasks" },
        "title": {
          "type": "string",
          "description": "Custom title for the run"
        },
        "status-checks": { "$ref": "#/$defs/StatusChecks" }
      },
      "unevaluatedProperties": false
    },

    "GitHubPullRequestTrigger": {
      "type": "object",
      "description": "Configuration for GitHub pull request event triggers. Triggered on PR lifecycle events (opened, reopened, synchronize, closed). Default actions: [opened, reopened, synchronize]. Supports conditional execution, initialization parameter mapping, selective task targeting, custom run titles, and GitHub status check reporting.",
      "properties": {
        "init": { "$ref": "#/$defs/InitParameters" },
        "if": {
          "type": "string",
          "description": "Condition for trigger activation"
        },
        "target": { "$ref": "#/$defs/TargetTasks" },
        "title": {
          "type": "string",
          "description": "Custom title for the run"
        },
        "actions": {
          "type": "array",
          "items": { "type": "string" },
          "description": "PR actions that trigger the run. Available actions: 'opened' (PR is opened), 'reopened' (previously closed PR is reopened), 'synchronize' (PR branch is updated), 'closed' (PR is closed). Default: [opened, reopened, synchronize] if not specified."
        },
        "status-checks": { "$ref": "#/$defs/StatusChecks" }
      },
      "unevaluatedProperties": false
    },

    "GitHubMergeGroupTrigger": {
      "type": "object",
      "description": "Configuration for GitHub merge group event triggers",
      "properties": {
        "init": { "$ref": "#/$defs/InitParameters" },
        "if": {
          "type": "string",
          "description": "Condition for trigger activation"
        },
        "target": { "$ref": "#/$defs/TargetTasks" },
        "title": {
          "type": "string",
          "description": "Custom title for the run"
        },
        "actions": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Merge group actions that trigger the run"
        },
        "status-checks": { "$ref": "#/$defs/StatusChecks" }
      },
      "unevaluatedProperties": false
    },

    "GitLabTriggers": {
      "type": "object",
      "description": "GitLab event triggers for automated run execution. Supports push events (branch updates), tag-push events (tag creation), and merge-request events (MR lifecycle). Each trigger provides GitLab-specific event context and supports conditional execution, initialization parameters, target tasks, and custom run titles.",
      "properties": {
        "push": {
          "oneOf": [
            { "$ref": "#/$defs/BaseTrigger" },
            { "type": "array", "items": { "$ref": "#/$defs/BaseTrigger" } }
          ]
        },
        "tag-push": {
          "oneOf": [
            { "$ref": "#/$defs/BaseTrigger" },
            { "type": "array", "items": { "$ref": "#/$defs/BaseTrigger" } }
          ]
        },
        "merge-request": {
          "oneOf": [
            { "$ref": "#/$defs/GitLabMergeRequestTrigger" },
            {
              "type": "array",
              "items": { "$ref": "#/$defs/GitLabMergeRequestTrigger" }
            }
          ]
        }
      },
      "unevaluatedProperties": false
    },

    "GitLabMergeRequestTrigger": {
      "type": "object",
      "description": "Configuration for GitLab merge request event triggers",
      "properties": {
        "init": { "$ref": "#/$defs/InitParameters" },
        "if": { "type": "string" },
        "target": { "$ref": "#/$defs/TargetTasks" },
        "title": { "type": "string" },
        "actions": { "type": "array", "items": { "type": "string" } }
      },
      "unevaluatedProperties": false
    },

    "CronTriggers": {
      "type": "array",
      "description": "Scheduled cron triggers for automated run execution using cron expressions with optional timezone specification. Each trigger requires a unique key and schedule. Provides rich event context including time fields in both schedule timezone and UTC. Useful for recurring workflows like nightly builds, cache warming, or scheduled deployments.",
      "items": {
        "type": "object",
        "properties": {
          "init": { "$ref": "#/$defs/InitParameters" },
          "if": {
            "type": "string",
            "description": "Condition for trigger activation"
          },
          "target": { "$ref": "#/$defs/TargetTasks" },
          "title": {
            "type": "string",
            "description": "Custom title for the run"
          },
          "key": {
            "type": "string",
            "description": "Unique identifier for the cron trigger. Must be unique within the organization. Used for identification in logs, UI, and manual trigger execution via CLI."
          },
          "schedule": {
            "type": "string",
            "description": "Cron expression for scheduling with optional timezone. Standard format: 'minute hour day-of-month month day-of-week'. With timezone: '30 9 * * * America/New_York'. Default timezone: UTC. Provides event context: event.cron.year, event.cron.hour, event.cron.utc.hour, etc."
          },
          "branch": {
            "type": "string",
            "description": "Git branch to use for the run"
          },
          "reset-tool-cache": {
            "type": "boolean",
            "description": "Whether to reset tool cache"
          }
        },
        "required": ["key", "schedule"],
        "unevaluatedProperties": false
      }
    },

    "CLITrigger": {
      "type": "object",
      "description": "Configuration for manual CLI-triggered runs",
      "properties": {
        "init": { "$ref": "#/$defs/InitParameters" },
        "title": {
          "type": "string",
          "description": "Custom title for CLI runs"
        }
      },
      "unevaluatedProperties": false
    },

    "DispatchTriggers": {
      "type": "array",
      "description": "API dispatch triggers for programmatic run execution. Allows on-demand execution via CLI (`mint dispatch`), API calls, or Cloud UI. Each trigger requires a globally unique key and can define parameters for user input. Parameters are accessible via event.dispatch.params context and must be explicitly mapped to initialization parameters. Provides flexible workflow orchestration for deployment pipelines, manual testing, or external integrations.",
      "items": {
        "type": "object",
        "properties": {
          "init": { "$ref": "#/$defs/InitParameters" },
          "if": { "type": "string" },
          "target": { "$ref": "#/$defs/TargetTasks" },
          "title": { "type": "string" },
          "key": {
            "type": "string",
            "description": "Globally unique key for the dispatch trigger. Must be unique across your organization. Used for CLI dispatch commands (`mint dispatch <key>`), API calls, and UI identification. Should be descriptive of the dispatch purpose (e.g., 'deploy-application', 'run-integration-tests')."
          },
          "params": {
            "type": "array",
            "description": "Parameters that can be provided when dispatching. Each parameter defines input fields for users to specify when triggering the dispatch. Parameters are accessible via ${{ event.dispatch.params.parameter-key }} and must be mapped to initialization parameters in the 'init' section. Supports default values and required validation.",
            "items": {
              "type": "object",
              "properties": {
                "key": {
                  "type": "string",
                  "description": "Parameter key for referencing via ${{ event.dispatch.params.key-name }}. Should be descriptive and follow naming conventions."
                },
                "name": {
                  "type": "string",
                  "description": "Human-readable display name shown in UI and CLI prompts. Should be clear and descriptive for users."
                },
                "description": {
                  "type": "string",
                  "description": "Parameter description"
                },
                "default": {
                  "$ref": "#/$defs/PrimitiveValue",
                  "description": "Default value"
                },
                "required": {
                  "type": "boolean",
                  "description": "Whether parameter is required"
                }
              },
              "required": ["key"],
              "unevaluatedProperties": false
            }
          }
        },
        "required": ["key"],
        "unevaluatedProperties": false
      }
    },

    "BaseTrigger": {
      "type": "object",
      "description": "Base trigger configuration with common properties",
      "properties": {
        "init": { "$ref": "#/$defs/InitParameters" },
        "if": { "type": "string" },
        "target": { "$ref": "#/$defs/TargetTasks" },
        "title": { "type": "string" }
      },
      "unevaluatedProperties": false
    },

    "InitParameters": {
      "type": "object",
      "additionalProperties": { "$ref": "#/$defs/PrimitiveValue" },
      "description": "Initialization parameters passed to the run or embedded run"
    },

    "TargetTasks": {
      "oneOf": [
        { "type": "string" },
        { "type": "array", "items": { "type": "string" } }
      ],
      "description": "Specific tasks to execute when triggered"
    },

    "StatusChecks": {
      "type": "array",
      "description": "GitHub status check configuration",
      "items": {
        "type": "object",
        "properties": {
          "tasks": { "$ref": "#/$defs/TargetTasks" },
          "name": {
            "type": "string",
            "description": "Custom name for the status check"
          }
        },
        "required": ["tasks"]
      }
    },

    "ConcurrencyPool": {
      "type": "object",
      "description": "Configuration for limiting concurrent task execution across the run",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the concurrency pool"
        },
        "capacity": {
          "type": "integer",
          "minimum": 1,
          "description": "Maximum number of concurrent tasks in this pool"
        },
        "on-overflow": {
          "type": "string",
          "enum": ["queue", "cancel-waiting", "cancel-running"],
          "description": "Action to take when pool capacity is exceeded"
        },
        "if": {
          "type": "string",
          "description": "Condition for pool activation"
        }
      },
      "required": ["id", "capacity", "on-overflow"],
      "unevaluatedProperties": false
    },

    "ToolCache": {
      "type": "object",
      "description": "Global tool cache configuration",
      "properties": {
        "vault": {
          "type": "string",
          "description": "Vault to use for tool cache"
        }
      },
      "unevaluatedProperties": false
    },

    "BaseLayer": {
      "type": "object",
      "description": "Base container layer configuration that defines the operating system, version, and Mint configuration tag for task execution. Currently supports Ubuntu 22.04 (tag 1.0 with Docker 26.0.1) and Ubuntu 24.04 (tag 1.1 with Docker 28.0.4). The base layer determines available system packages, pre-installed Docker version, and tool cache compatibility. Different embedded runs can specify different base layers than their parent run.",
      "properties": {
        "os": {
          "$ref": "#/$defs/PrimitiveValue",
          "description": "Operating system for the base container layer. Currently supported values are 'ubuntu 24.04' and 'ubuntu 22.04'. The OS version determines available system packages and affects tool cache compatibility. Different embedded runs can specify different operating systems than their parent run."
        },
        "tag": {
          "$ref": "#/$defs/PrimitiveValue",
          "description": "Mint configuration version tag that specifies the pre-configured software environment. Tag '1.1' includes Docker 28.0.4 (for Ubuntu 24.04), while tag '1.0' includes Docker 26.0.1 (for Ubuntu 22.04). Each tag represents a specific, tested configuration of system tools and dependencies."
        },
        "arch": {
          "$ref": "#/$defs/PrimitiveValue",
          "description": "CPU architecture for task execution. Common values include 'x86', 'arm64', and 'x86_64'. Architecture selection affects agent allocation and compatibility with certain packages or Docker images. Can be used with template expressions for dynamic architecture selection in parallel builds."
        }
      },
      "unevaluatedProperties": false
    }
  }
}
